//! Reflection Engine — "What I think" (§8.5, §12.3)
//!
//! The reflection engine generates higher-order thoughts from accumulated
//! episodic and semantic memories. This is where NPC "wisdom" emerges.
//!
//! Reflection is a Tier 2 LLM operation (async, non-blocking):
//!   - Runs periodically (configurable interval, default: every 5 game-minutes)
//!   - Takes the N most recent/important episodic memories as input
//!   - Produces `ReflectiveMemory` outputs with beliefs, questions, mood shifts
//!   - Falls back to rule-based summarisation if LLM is unavailable
//!
//! Grounded in Flavell's metacognition theory (1979).

use crate::error::MemzError;
use crate::memory::episodic::EpisodicMemory;
use crate::memory::reflective::ReflectiveMemory;
use crate::memory::semantic::SemanticMemory;
use crate::types::{GameTimestamp, MemoryId};

/// Configuration for the reflection engine.
#[derive(Debug, Clone)]
pub struct ReflectionConfig {
    /// Maximum number of recent episodic memories to consider per reflection.
    pub max_input_memories: usize,
    /// Maximum number of existing semantic memories to include as context.
    pub max_context_memories: usize,
    /// Minimum importance threshold for memories to be considered.
    pub importance_threshold: f32,
    /// Reflection interval in game-minutes.
    pub interval_minutes: f32,
}

impl Default for ReflectionConfig {
    fn default() -> Self {
        Self {
            max_input_memories: 10,
            max_context_memories: 5,
            importance_threshold: 0.3,
            interval_minutes: 5.0,
        }
    }
}

/// Input bundle for a single reflection operation.
#[derive(Debug)]
pub struct ReflectionInput {
    /// NPC's name (for prompt personalisation).
    pub npc_name: String,
    /// NPC's profession/role (for context).
    pub npc_role: String,
    /// Recent episodic memories to reflect on.
    pub recent_episodic: Vec<EpisodicMemory>,
    /// Existing semantic knowledge (beliefs, known facts).
    pub existing_semantic: Vec<SemanticMemory>,
    /// Current game timestamp.
    pub current_time: GameTimestamp,
    /// Personality summary for prompt context.
    pub personality_summary: String,
}

/// Output of a reflection — either LLM-generated or rule-based fallback.
#[derive(Debug)]
pub struct ReflectionOutput {
    /// The generated reflective memory.
    pub memory: ReflectiveMemory,
    /// Whether this was generated by LLM (true) or rule-based fallback (false).
    pub llm_generated: bool,
}

/// Generate a reflection using rule-based fallback (Tier 0).
///
/// This produces a simpler but always-available reflection by
/// identifying patterns in recent episodic memories.
pub fn reflect_rule_based(input: &ReflectionInput) -> Result<ReflectionOutput, MemzError> {
    // Identify the most emotionally significant recent memory.
    let most_significant = input
        .recent_episodic
        .iter()
        .max_by(|a, b| {
            a.emotional_valence
                .abs()
                .partial_cmp(&b.emotional_valence.abs())
                .unwrap_or(std::cmp::Ordering::Equal)
        });

    let reflection_text = match most_significant {
        Some(memory) => {
            if memory.emotional_valence > 0.5 {
                format!(
                    "I've been thinking about what happened recently — {}. It was a good experience. I feel like things are going well.",
                    memory.event
                )
            } else if memory.emotional_valence < -0.5 {
                format!(
                    "I can't stop thinking about {}. It troubles me. I need to be more careful.",
                    memory.event
                )
            } else {
                format!(
                    "Life continues as usual. I observed that {} happened recently. I wonder what it means.",
                    memory.event
                )
            }
        }
        None => "Things have been quiet lately. Nothing much to think about.".to_string(),
    };

    let basis: Vec<MemoryId> = input.recent_episodic.iter().map(|m| m.id).collect();

    let mut memory =
        ReflectiveMemory::new(reflection_text, basis, 0.5, input.current_time);

    // Generate simple questions based on participants in recent memories.
    let questions: Vec<String> = input
        .recent_episodic
        .iter()
        .filter(|m| m.importance > 0.5)
        .take(2)
        .map(|m| format!("I wonder what will come of the events involving {}...", m.event))
        .collect();

    if !questions.is_empty() {
        memory = memory.with_questions(questions);
    }

    Ok(ReflectionOutput {
        memory,
        llm_generated: false,
    })
}

/// Determine whether an NPC should reflect right now.
///
/// Based on:
/// - Time since last reflection
/// - Number of unprocessed episodic memories
/// - Emotional intensity of recent events
#[must_use]
pub fn should_reflect(
    last_reflection_tick: u64,
    current_tick: u64,
    unprocessed_episodic_count: usize,
    recent_max_emotional_intensity: f32,
    config: &ReflectionConfig,
) -> bool {
    // Convert interval from game-minutes to ticks.
    // Assume 20 ticks/sec, 60 sec/min → 1200 ticks/game-minute.
    let interval_ticks = (config.interval_minutes * 1200.0) as u64;
    let ticks_since_last = current_tick.saturating_sub(last_reflection_tick);

    // Normal interval-based trigger.
    if ticks_since_last >= interval_ticks && unprocessed_episodic_count >= 3 {
        return true;
    }

    // Urgent trigger: highly emotional events force earlier reflection.
    if recent_max_emotional_intensity > 0.8 && ticks_since_last >= interval_ticks / 2 {
        return true;
    }

    // Overflow trigger: too many unprocessed memories.
    if unprocessed_episodic_count >= 15 {
        return true;
    }

    false
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn should_reflect_after_interval() {
        let config = ReflectionConfig::default();
        assert!(should_reflect(0, 10_000, 5, 0.3, &config));
    }

    #[test]
    fn should_not_reflect_too_soon() {
        let config = ReflectionConfig::default();
        assert!(!should_reflect(0, 100, 5, 0.3, &config));
    }

    #[test]
    fn emotional_events_trigger_early_reflection() {
        let config = ReflectionConfig::default();
        // Half the normal interval, but high emotional intensity.
        let half_interval = (config.interval_minutes * 1200.0 / 2.0) as u64;
        assert!(should_reflect(0, half_interval, 3, 0.9, &config));
    }

    #[test]
    fn overflow_triggers_reflection() {
        let config = ReflectionConfig::default();
        assert!(should_reflect(0, 1, 15, 0.1, &config));
    }
}
