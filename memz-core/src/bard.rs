//! Bard System — Living lore through song and story (§19)
//!
//! Wandering bard NPCs compose and perform songs based on actual in-game events.
//! Songs are persistent cultural artifacts that spread between settlements,
//! creating a living oral history.
//!
//! ## Song Pipeline
//!
//! 1. Event collection: Bards remember dramatic events (combat, quests, betrayals)
//! 2. Composition: Tier 2 LLM generates a song from event memories
//! 3. Performance: Bard performs in settlements, spreading the song
//! 4. Cultural persistence: Popular songs are remembered across the world
//! 5. Evolution: Songs may be modified as they spread (telephone effect)

use serde::{Deserialize, Serialize};

use crate::types::{EntityId, GameTimestamp, MemoryId, SettlementId};

/// A bard's musical composition based on real game events.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BardComposition {
    /// Unique identifier.
    pub id: MemoryId,
    /// Title of the composition.
    pub title: String,
    /// Verses of the song (each line is a string).
    pub verses: Vec<String>,
    /// The bard who composed this.
    pub composer: EntityId,
    /// Artistic style of the composition.
    pub style: BardStyle,
    /// Memory IDs this song is based on.
    pub source_memories: Vec<MemoryId>,
    /// Main character of the song (the hero/villain of the story).
    pub subject: Option<EntityId>,
    /// When this was composed.
    pub composed_at: GameTimestamp,
    /// How many times this has been performed.
    pub performance_count: u32,
    /// Settlements where this song has been performed.
    pub performed_at: Vec<SettlementId>,
    /// Popularity score (0.0–1.0), increases with performances.
    pub popularity: f32,
    /// Whether this composition was generated by LLM (true) or rule-based (false).
    pub llm_generated: bool,
}

/// Artistic style of a bard's composition (§19).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum BardStyle {
    /// Epic ballad — grand, sweeping tales of heroism.
    Epic,
    /// Comic limerick — humorous, light-hearted stories.
    Comic,
    /// Tragic elegy — mournful songs of loss and sorrow.
    Tragic,
    /// Mysterious riddle-song — cryptic, thought-provoking.
    Mystery,
    /// Romantic serenade — songs of love and devotion.
    Romantic,
    /// Martial war-chant — aggressive, rallying songs.
    Martial,
}

impl BardStyle {
    /// Get a human-readable description of this style.
    #[must_use]
    pub fn description(&self) -> &'static str {
        match self {
            Self::Epic => "grand and sweeping, with heroic imagery and dramatic pacing",
            Self::Comic => "light and humorous, with clever wordplay and amusing twists",
            Self::Tragic => "mournful and poignant, with themes of loss and remembrance",
            Self::Mystery => "cryptic and enigmatic, with riddles woven into the verses",
            Self::Romantic => "tender and passionate, celebrating love and devotion",
            Self::Martial => "fierce and rallying, with driving rhythms and battle imagery",
        }
    }

    /// Select a bard style appropriate for the emotional tone of events.
    #[must_use]
    pub fn from_emotional_tone(valence: f32, intensity: f32) -> Self {
        if intensity >= 0.8 {
            if valence > 0.3 {
                Self::Epic
            } else {
                Self::Tragic
            }
        } else if valence > 0.5 {
            Self::Romantic
        } else if valence < -0.5 {
            Self::Martial
        } else if intensity < 0.3 {
            Self::Comic
        } else {
            Self::Mystery
        }
    }
}

impl BardComposition {
    /// Create a new composition.
    #[must_use]
    pub fn new(
        title: String,
        verses: Vec<String>,
        composer: EntityId,
        style: BardStyle,
        source_memories: Vec<MemoryId>,
        subject: Option<EntityId>,
        timestamp: GameTimestamp,
        llm_generated: bool,
    ) -> Self {
        Self {
            id: MemoryId::new(),
            title,
            verses,
            composer,
            style,
            source_memories,
            subject,
            composed_at: timestamp,
            performance_count: 0,
            performed_at: Vec::new(),
            popularity: 0.0,
            llm_generated,
        }
    }

    /// Record a performance of this song at a settlement.
    pub fn record_performance(&mut self, settlement: SettlementId) {
        self.performance_count += 1;
        if !self.performed_at.contains(&settlement) {
            self.performed_at.push(settlement);
        }
        // Popularity increases with performances but has diminishing returns
        self.popularity = (1.0 - (-0.1 * self.performance_count as f32).exp()).min(1.0);
    }

    /// Get the full text of the song.
    #[must_use]
    pub fn full_text(&self) -> String {
        let mut text = format!("\"{}\"", self.title);
        text.push('\n');
        for verse in &self.verses {
            text.push_str(verse);
            text.push('\n');
        }
        text
    }

    /// Number of unique settlements where this has been performed.
    #[must_use]
    pub fn reach(&self) -> usize {
        self.performed_at.len()
    }
}

/// Rule-based fallback for bard composition (Tier 0).
///
/// Produces simple template-based songs when LLM is unavailable.
#[must_use] 
pub fn compose_rule_based(
    composer: EntityId,
    subject: Option<EntityId>,
    event_descriptions: &[String],
    avg_valence: f32,
    timestamp: GameTimestamp,
) -> BardComposition {
    let style = BardStyle::from_emotional_tone(avg_valence, avg_valence.abs());

    let (title, verses) = match style {
        BardStyle::Epic => {
            let title = "The Ballad of the Brave".to_string();
            let mut verses = vec![
                "Hear ye, hear ye, gather round!".to_string(),
                "A tale of courage, honor-bound!".to_string(),
            ];
            for desc in event_descriptions.iter().take(4) {
                verses.push(format!("They say that {}.", desc.to_lowercase()));
            }
            verses.push("And so the legend grows each day,".to_string());
            verses.push("As travelers share along the way!".to_string());
            (title, verses)
        }
        BardStyle::Tragic => {
            let title = "A Lament for the Fallen".to_string();
            let mut verses = vec![
                "The wind carries sorrow through the land,".to_string(),
                "Where once stood strong, now falls like sand.".to_string(),
            ];
            for desc in event_descriptions.iter().take(3) {
                verses.push(format!("'Twas said that {}.", desc.to_lowercase()));
            }
            verses.push("Remember them when stars appear,".to_string());
            verses.push("Their memory lingers, ever near.".to_string());
            (title, verses)
        }
        BardStyle::Comic => {
            let title = "A Merry Misadventure".to_string();
            let mut verses = vec![
                "Now listen close, I'll tell you true,".to_string(),
                "A funny tale — believe it, do!".to_string(),
            ];
            for desc in event_descriptions.iter().take(3) {
                verses.push(format!("Would you believe that {}?", desc.to_lowercase()));
            }
            verses.push("Ha! Such is life in this odd land,".to_string());
            verses.push("Where nothing goes quite as we planned!".to_string());
            (title, verses)
        }
        BardStyle::Martial => {
            let title = "A Call to Arms".to_string();
            let mut verses = vec![
                "Steel and fire! Blood and bone!".to_string(),
                "Stand together! Not alone!".to_string(),
            ];
            for desc in event_descriptions.iter().take(3) {
                verses.push(format!("For {}!", desc.to_lowercase()));
            }
            verses.push("Rise and fight! The battle calls!".to_string());
            verses.push("We shall not rest till darkness falls!".to_string());
            (title, verses)
        }
        _ => {
            let title = "A Song of the Road".to_string();
            let mut verses = vec![
                "Along the path where travelers go,".to_string(),
                "There are stories you should know.".to_string(),
            ];
            for desc in event_descriptions.iter().take(4) {
                verses.push(format!("It's said that {}.", desc.to_lowercase()));
            }
            verses.push("Such tales are born and travel far,".to_string());
            verses.push("Guided by the evening star.".to_string());
            (title, verses)
        }
    };

    BardComposition::new(
        title,
        verses,
        composer,
        style,
        vec![],
        subject,
        timestamp,
        false,
    )
}

/// The bard's song repertoire — manages compositions per bard NPC.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct Repertoire {
    /// All compositions this bard knows.
    pub songs: Vec<BardComposition>,
    /// Maximum songs a bard can remember.
    pub max_songs: usize,
}

impl Repertoire {
    /// Create a new repertoire with a capacity limit.
    #[must_use]
    pub fn new(max_songs: usize) -> Self {
        Self {
            songs: Vec::new(),
            max_songs,
        }
    }

    /// Add a new composition to the repertoire.
    ///
    /// If at capacity, drops the least popular song.
    pub fn add(&mut self, song: BardComposition) {
        if self.songs.len() >= self.max_songs {
            // Drop least popular
            if let Some(min_idx) = self
                .songs
                .iter()
                .enumerate()
                .min_by(|(_, a), (_, b)| {
                    a.popularity
                        .partial_cmp(&b.popularity)
                        .unwrap_or(std::cmp::Ordering::Equal)
                })
                .map(|(i, _)| i)
            {
                self.songs.swap_remove(min_idx);
            }
        }
        self.songs.push(song);
    }

    /// Select the best song to perform right now.
    ///
    /// Prefers songs that haven't been performed at the current settlement.
    #[must_use] 
    pub fn select_for_performance(
        &self,
        current_settlement: SettlementId,
    ) -> Option<&BardComposition> {
        // Prefer songs not yet performed here
        let novel: Vec<&BardComposition> = self
            .songs
            .iter()
            .filter(|s| !s.performed_at.contains(&current_settlement))
            .collect();

        if let Some(best) = novel
            .iter()
            .max_by(|a, b| {
                a.popularity
                    .partial_cmp(&b.popularity)
                    .unwrap_or(std::cmp::Ordering::Equal)
            })
        {
            return Some(best);
        }

        // Fall back to most popular overall
        self.songs.iter().max_by(|a, b| {
            a.popularity
                .partial_cmp(&b.popularity)
                .unwrap_or(std::cmp::Ordering::Equal)
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::{EntityId, GameTimestamp, SettlementId};

    #[test]
    fn compose_rule_based_epic() {
        let composer = EntityId::new();
        let events = vec![
            "a hero fought off bandits".to_string(),
            "the village was saved".to_string(),
        ];

        let song = compose_rule_based(composer, None, &events, 0.8, GameTimestamp::now(36_000));
        assert_eq!(song.style, BardStyle::Epic);
        assert!(!song.title.is_empty());
        assert!(song.verses.len() >= 4);
        assert!(!song.llm_generated);
    }

    #[test]
    fn compose_rule_based_tragic() {
        let composer = EntityId::new();
        let events = vec!["a great warrior fell in battle".to_string()];

        let song = compose_rule_based(composer, None, &events, -0.9, GameTimestamp::now(36_000));
        assert_eq!(song.style, BardStyle::Tragic);
    }

    #[test]
    fn performance_tracking() {
        let mut song = compose_rule_based(
            EntityId::new(),
            None,
            &["an event".to_string()],
            0.5,
            GameTimestamp::now(36_000),
        );

        let s1 = SettlementId::new();
        let s2 = SettlementId::new();

        song.record_performance(s1);
        assert_eq!(song.performance_count, 1);
        assert_eq!(song.reach(), 1);

        song.record_performance(s1); // same settlement
        assert_eq!(song.performance_count, 2);
        assert_eq!(song.reach(), 1); // still only 1 unique

        song.record_performance(s2);
        assert_eq!(song.reach(), 2);
        assert!(song.popularity > 0.0);
    }

    #[test]
    fn repertoire_capacity() {
        let mut rep = Repertoire::new(2);
        let ts = GameTimestamp::now(36_000);

        rep.add(compose_rule_based(EntityId::new(), None, &["event1".to_string()], 0.5, ts));
        rep.add(compose_rule_based(EntityId::new(), None, &["event2".to_string()], 0.5, ts));
        assert_eq!(rep.songs.len(), 2);

        // Adding a third should drop the least popular
        rep.add(compose_rule_based(EntityId::new(), None, &["event3".to_string()], 0.5, ts));
        assert_eq!(rep.songs.len(), 2);
    }

    #[test]
    fn repertoire_selects_novel_songs() {
        let mut rep = Repertoire::new(10);
        let ts = GameTimestamp::now(36_000);
        let s1 = SettlementId::new();

        let mut song1 = compose_rule_based(EntityId::new(), None, &["event1".to_string()], 0.5, ts);
        song1.record_performance(s1);
        rep.add(song1);

        let song2 = compose_rule_based(EntityId::new(), None, &["event2".to_string()], 0.5, ts);
        rep.add(song2);

        let selected = rep.select_for_performance(s1);
        assert!(selected.is_some());
        // Should prefer the song not yet performed at s1
        let selected = selected.expect("should have a song");
        assert!(!selected.performed_at.contains(&s1));
    }

    #[test]
    fn bard_style_selection() {
        assert_eq!(
            BardStyle::from_emotional_tone(0.8, 0.9),
            BardStyle::Epic
        );
        assert_eq!(
            BardStyle::from_emotional_tone(-0.9, 0.9),
            BardStyle::Tragic
        );
        assert_eq!(
            BardStyle::from_emotional_tone(0.1, 0.1),
            BardStyle::Comic
        );
    }
}
