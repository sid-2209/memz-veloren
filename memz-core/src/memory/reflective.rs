//! Reflective Memory — "What I think" (§8.5)
//!
//! Higher-order thoughts generated by reflecting on accumulated memories.
//! This is where NPC "wisdom" and "insight" emerge.
//!
//! Grounded in Flavell's metacognition theory (1979).

use serde::{Deserialize, Serialize};

use crate::types::{GameTimestamp, MemoryId, PADState};

/// A reflective thought — a higher-order conclusion drawn from other memories.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReflectiveMemory {
    /// Unique identifier.
    pub id: MemoryId,
    /// The reflection in natural language.
    pub reflection: String,
    /// IDs of memories that formed the basis for this reflection.
    pub basis: Vec<MemoryId>,
    /// Confidence in this reflection (0.0 to 1.0).
    pub confidence: f32,
    /// When this reflection was generated.
    pub generated_at: GameTimestamp,
    /// Mood shift that resulted from this reflection.
    pub mood_shift: Option<PADState>,
    /// New beliefs or questions that emerged.
    pub new_beliefs: Vec<String>,
    /// Things the character now wonders about.
    pub questions: Vec<String>,
}

impl ReflectiveMemory {
    /// Create a new reflective memory.
    #[must_use]
    pub fn new(
        reflection: impl Into<String>,
        basis: Vec<MemoryId>,
        confidence: f32,
        timestamp: GameTimestamp,
    ) -> Self {
        Self {
            id: MemoryId::new(),
            reflection: reflection.into(),
            basis,
            confidence: confidence.clamp(0.0, 1.0),
            generated_at: timestamp,
            mood_shift: None,
            new_beliefs: Vec::new(),
            questions: Vec::new(),
        }
    }

    /// Add new beliefs discovered during reflection.
    pub fn with_beliefs(mut self, beliefs: Vec<String>) -> Self {
        self.new_beliefs = beliefs;
        self
    }

    /// Add questions that emerged during reflection.
    pub fn with_questions(mut self, questions: Vec<String>) -> Self {
        self.questions = questions;
        self
    }

    /// Set the mood shift resulting from this reflection.
    pub fn with_mood_shift(mut self, shift: PADState) -> Self {
        self.mood_shift = Some(shift);
        self
    }
}
