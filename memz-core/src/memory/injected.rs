//! Injected Memory — "Backstory planted by the game designer / player" (§8.6)
//!
//! Pre-seeded memories that are never generated by the LLM.
//! Used for backstory, world lore, quest-relevant knowledge, and
//! the "First 5 Minutes" experience.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

use crate::types::{Embedding, EntityId, GameTimestamp, MemoryId};

/// Priority level for injected memories.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum InjectedPriority {
    /// Background flavor — may be forgotten over time.
    Low,
    /// Standard backstory element.
    Normal,
    /// Critical for character identity.
    High,
    /// Core identity — never decays, always influences behaviour.
    Core,
}

/// An injected memory — a backstory element planted by the game designer.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct InjectedMemory {
    /// Unique identifier.
    pub id: MemoryId,
    /// The backstory text in natural language.
    pub content: String,
    /// Emotional weight of this memory (0.0 = neutral, 1.0 = defining trauma/joy).
    pub emotional_weight: f32,
    /// Whether this memory actively affects NPC behaviour.
    pub affects_behavior: bool,
    /// Which NPCs are aware of this memory (for social consistency).
    pub known_to_npcs: Vec<EntityId>,
    /// Priority level — how resistant to decay this memory is.
    pub priority: InjectedPriority,
    /// Optional embedding for retrieval matching.
    pub embedding: Option<Embedding>,
    /// When this memory was ostensibly formed (in game time).
    pub memory_timestamp: GameTimestamp,
    /// When this memory was actually injected (real time).
    pub injected_at: DateTime<Utc>,
    /// Tags for filtering and categorisation.
    pub tags: Vec<String>,
    /// Whether this memory is part of the "first 5 minutes" experience.
    pub is_first_five_minutes: bool,
}

impl InjectedMemory {
    /// Create a new injected memory.
    #[must_use]
    pub fn new(
        content: impl Into<String>,
        emotional_weight: f32,
        timestamp: GameTimestamp,
        priority: InjectedPriority,
    ) -> Self {
        Self {
            id: MemoryId::new(),
            content: content.into(),
            emotional_weight: emotional_weight.clamp(0.0, 1.0),
            affects_behavior: true,
            known_to_npcs: Vec::new(),
            priority,
            embedding: None,
            memory_timestamp: timestamp,
            injected_at: Utc::now(),
            tags: Vec::new(),
            is_first_five_minutes: false,
        }
    }

    /// Create a core identity memory that never decays.
    #[must_use]
    pub fn core_identity(
        content: impl Into<String>,
        timestamp: GameTimestamp,
    ) -> Self {
        Self::new(content, 1.0, timestamp, InjectedPriority::Core)
    }

    /// Create a "first 5 minutes" memory for immediate NPC engagement.
    #[must_use]
    pub fn first_five_minutes(
        content: impl Into<String>,
        emotional_weight: f32,
        timestamp: GameTimestamp,
    ) -> Self {
        let mut mem = Self::new(content, emotional_weight, timestamp, InjectedPriority::High);
        mem.is_first_five_minutes = true;
        mem
    }

    /// Add NPCs who know about this memory.
    pub fn with_known_npcs(mut self, npcs: Vec<EntityId>) -> Self {
        self.known_to_npcs = npcs;
        self
    }

    /// Add tags for categorisation.
    pub fn with_tags(mut self, tags: Vec<String>) -> Self {
        self.tags = tags;
        self
    }

    /// Whether this memory should be immune to decay.
    #[must_use]
    pub fn is_permanent(&self) -> bool {
        self.priority == InjectedPriority::Core
    }

    /// Effective importance for retrieval scoring.
    #[must_use]
    pub fn importance(&self) -> f32 {
        match self.priority {
            InjectedPriority::Low => 0.3 + self.emotional_weight * 0.2,
            InjectedPriority::Normal => 0.5 + self.emotional_weight * 0.2,
            InjectedPriority::High => 0.7 + self.emotional_weight * 0.2,
            InjectedPriority::Core => 0.9 + self.emotional_weight * 0.1,
        }
    }
}
